Amazon S3
=========

All Django projects involve some kind of static (CSS/JS) resources and
many user uploaded resouces like avatars. When deploying to a single
server these can be kept on the local file system but in a larger server
cluster that isn\'t feasible. Other deployment environments such as
Heroku or Elastic Beanstalk don\'t provide access to the local
filesystem. For these scenarios, Amazon\'s Simple Cloud Storage Service
(S3) can provided a shared storage location for your shared assets.

Static Assets and Public Uploads
--------------------------------

This is the most common use case for S3. Moving your static assets to S3
makes it easy to setup CloudFront as a CDN for them saving your web
servers CPU and bandwidth to serve the application instead. Moving the
public uploads to S3 can also benefit from a CDN. Having a shared
storage location means all webservers in the cluster will have access to
the resources without configuring and maintaining any network mounts.

Since it\'s a fairly common configuration, there are a number of great
tools to make this easy and documentation on how to enable them in your
project.
[django-storages](https://django-storages.readthedocs.io/en/latest/index.html)
along with [boto3](https://boto3.readthedocs.io/en/latest/) is the
preferred method for configuring Django to use S3 for either static or
media resources. The best place to get started on this is our own blog
post on this exact topic:
<https://www.caktusgroup.com/blog/2014/11/10/Using-Amazon-S3-to-store-your-Django-sites-static-and-media-files/>

Private Uploads
---------------

There are times when you want to handle user uploads for content that
shouldn\'t be served publicly on the site. These might be resources
restricted to the user who uploaded it or to a group of users. On the
Django side, private uploads are handled similarly to public uploads.
It\'s still recommended that you use django-storages and boto3. However,
the bucket configuration on the AWS side needs more restrictive
permissions. If you follow the directions in the post related to public
media, then you\'ll have created a user to access the bucket from the
application side. To grant access to only that single user, you\'ll want
to create a policy like the following:

    {
        "Statement": [
            {
                "Sid": "SingleUserBucketReadWrite",
                "Effect": "Deny",
                "NotPrincipal": {
                    "AWS": [
                        "USER-ARN",
                    ]
                },
                "Action": [
                    "s3:GetBucketLocation",
                    "s3:GetObject",
                    "s3:ListBucket",
                    "s3:ListBucketMultipartUploads",
                    "s3:ListMultipartUploadParts",
                    "s3:AbortMultipartUpload",
                    "s3:PutObject"
                ],
                "Resource": [
                    "arn:aws:s3:::BUCKET-NAME",
                    "arn:aws:s3:::BUCKET-NAME/*"
                ]
            }
        ]
    }

To use this you would replace the `USER-ARN` with the user\'s ARN as
generated by AWS and `BUCKET-NAME` with the name of the bucket you\'ve
created. Note that this grants permission to list the bucket, get items
from the bucket, and add new uploads to the bucket but does not grant
the permission to delete items from the bucket. If you want to grant
that access it would be added to the `Action` list in the policy.

If you are using both public resources and private resources within a
single project, you\'ll have to go beyond configuring the
`DEFAULT_FILE_STORAGE` setting and explicitly configure each `FileField`
and `ImageField` to use the appropriate storage for that upload. This is
done by passing the `storage` instance to the field declaration. This
will allow you to use seperate buckets for the public and private files.
All together a project might use as many as three buckets: one
public/anonymous access bucket for static resources (JS/CSS), one
public/anonymous access bucket for public uploads, and one
private/restricted access bucket for private uploads. Note that the
private uploads can still be made accessible through a temporary signed
URL generated by the storage class.
